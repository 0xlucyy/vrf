# [Provably Fair](https://bullet-game.gitbook.io/bullet-game/architecture/provably-fair)
Website's VRF Mechanism:

- A random number, `beta`, is generated using a VRF.
- The modulo of `beta` divided by the size of the revolver is hashed with a random key (`salt`) and published as part of the `newGame` transaction made by the bot.
- When the game ends, the bot sends the following as part of the `endGame` transaction:
   - `beta`: The randomly generated number in hex.
   - `salt`: The key concatenated with the modulo of `beta` and the revolver size before generating the SHA-256 hash.
   - `publickey`: The public key of the VRF.
   - `proof`: The generated proof for this specific random number.
   - `alpha`: The input message to the VRF, created as `UNIX time + [array of each player's bets]`.
- Each invocation of the VRF is provided with a seed, randomly generated by the bot. This seed doesn't need to be revealed for verification.
- Using `publickey`, `proof`, and `alpha`, anyone can verify that `beta` is the correct VRF hash. With `beta` verified, the modulo of it divided by the size of the revolver, concatenated with `salt`, generates a SHA-256 hash. This hash should match the one passed to `newGame`, proving that the bullet's chamber index was randomly generated at the start of the game.


## Debugging steps

1. Verification of the Proof:

Action: We need to ensure that the proof (signature) for alpha is correctly generated using the private key and that the alpha and public key used during verification are consistent with those used during generation.

Debugging Steps:

    Log the alpha value both during its generation and during verification to ensure they match.
    Log the proof value both during its generation and during verification to ensure they match.
    Ensure that the public key used for verification is the correct corresponding public key for the private key that generated the proof.

2. Hash Verification:

Action: We need to ensure that the hashes of salt + beta and salt + proof match during the verification step.

Debugging Steps:

    Log the computed hashes of salt + beta and salt + proof during verification.
    Ensure that the salt used during verification matches the salt used during the initial hash generation.

3. Data Integrity:

Action: Ensure that all data remains unchanged between the generation and verification steps.

Debugging Steps:

    Log all data values (alpha, proof, beta, salt) during both generation and verification to ensure consistency.

4. Implementation Details:

Action: Review the cryptographic operations and ensure they're implemented correctly.

Debugging Steps:

    Ensure that the ECDSA library's operations are used correctly.
    Ensure that the correct hashing algorithm is used and that byte orders are consistent.

5. Randomness:

Action: Ensure that the salt remains consistent between the new_game and end_game functions.

Debugging Steps:

    Log the salt value during its generation and during verification to ensure they match.

6. Revolver Size Modulo Operation:

Action: Ensure consistent calculation of the bullet's chamber index.

Debugging Steps:

    Log the computed bullet's chamber index during both its generation and during verification.




 - [New Game](https://etherscan.io/tx/0x4bba2ee49e7e045dd96347f69a79080f580a520d2ed1356b2adfeb034e424840)
    - `_hashedBulletChamberIndex` telegram bot feeds value to `New Game`
 - [End Game](https://etherscan.io/tx/0xbc9f77cc69c5c098f60d0f3128eaa96188b7cdffb3ad9382159f3aa736fba88c)
    - `string[]` publickey, alpha, proof, beta, salt